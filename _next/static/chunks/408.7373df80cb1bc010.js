"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[408],{6408:(n,t,e)=>{e.r(t),e.d(t,{default:()=>s});var o=e(5155),r=e(2115),a=e(3264),i=e(7431);let s=()=>{let n=(0,r.useRef)(null);return(0,r.useEffect)(()=>{if(!n.current)return;let t=new a.Z58,e=new a.ubm(75,window.innerWidth/window.innerHeight,.1,1e3);e.position.z=1;let o=new i.JeP({canvas:n.current,antialias:!0});o.setSize(window.innerWidth,window.innerHeight),o.setPixelRatio(window.devicePixelRatio);let r={u_time:{value:0},u_resolution:{value:new a.I9Y(window.innerWidth,window.innerHeight)},u_rand_offset:{value:new a.I9Y(100*Math.random(),100*Math.random())}},s=new a.BKk({vertexShader:"\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = vec4(position, 1.0);\n        }\n    ",fragmentShader:"\n        #define PI 3.14159265359\n\n        varying vec2 vUv;\n        uniform float u_time;\n        uniform vec2 u_resolution;\n        uniform vec2 u_rand_offset; // NEW: Uniform for the random offset\n\n        // 2D Random function\n        float random (vec2 st) {\n            return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n        }\n\n        // 2D Noise function\n        float noise (vec2 st) {\n            vec2 i = floor(st);\n            vec2 f = fract(st);\n\n            float a = random(i);\n            float b = random(i + vec2(1.0, 0.0));\n            float c = random(i + vec2(0.0, 1.0));\n            float d = random(i + vec2(1.0, 1.0));\n\n            vec2 u = f*f*(3.0-2.0*f);\n            return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n        }\n\n        // Fractional Brownian Motion for turbulence (Further Optimized for Mobile)\n        float fbm(vec2 st) {\n            float value = 0.0;\n            float amplitude = 0.5;\n            for (int i = 0; i < 3; i++) {\n                value += amplitude * noise(st);\n                st *= 2.0;\n                amplitude *= 0.5;\n            }\n            return value;\n        }\n\n        // Star generation\n        float star(vec2 st, float size, float twinkle_speed) {\n            vec2 grid = floor(st);\n            vec2 f = fract(st);\n            float star_val = random(grid);\n\n            float t = u_time * twinkle_speed * random(grid) + star_val * 20.0;\n            float twinkle = sin(t) * 0.5 + 0.5;\n\n            if (star_val > 0.98) {\n                float m = 1.0 - smoothstep(0.0, size, length(f - 0.5));\n                return m * twinkle;\n            }\n            return 0.0;\n        }\n\n        // Mountain Generation\n        float mountain(vec2 st) {\n            float h = fbm(st * 0.3 + 0.3);\n            h = h * fbm(st * 0.8 + h);\n            h = pow(h, 2.5);\n            return h;\n        }\n\n        // REALISTIC Shooting Star\n        vec3 shooting_star(vec2 st, float time) {\n            float seed = floor(time * 0.3);\n            if (random(vec2(seed, seed * 0.5)) < 0.7) {\n                return vec3(0.0);\n            }\n            float time_frac = fract(time * 0.3);\n            vec2 start_pos = vec2(random(vec2(seed, seed)) * 2.0 - 1.0, 1.2);\n            vec2 dir = normalize(vec2(random(vec2(seed * 0.5, seed * 0.2)) * 0.6 - 0.3, -1.0));\n            float speed = random(vec2(seed * 0.1, seed * 0.9)) * 3.5 + 2.5;\n            dir.x += sin(time_frac * PI) * 0.2;\n            vec2 pos = start_pos + dir * time_frac * speed;\n            float star_dist = distance(st, pos);\n            float star_brightness = smoothstep(0.01, 0.0, star_dist);\n            float tail_length = 0.2;\n            float proj = dot(st - pos, -dir);\n            vec2 proj_pos = pos - dir * proj;\n            float tail_dist = distance(st, proj_pos);\n            float tail_brightness = 0.0;\n            if (proj > 0.0 && proj < tail_length) {\n                tail_brightness = smoothstep(0.03, 0.0, tail_dist) * (1.0 - proj / tail_length);\n            }\n            float total_brightness = star_brightness + tail_brightness * 0.8;\n            float life = sin(time_frac * PI);\n            vec3 star_color = vec3(0.8, 0.9, 1.0);\n            return vec3(total_brightness * life) * star_color;\n        }\n\n        void main() {\n            vec2 st = (gl_FragCoord.xy * 2.0 - u_resolution.xy) / u_resolution.y;\n            vec3 color = vec3(0.0, 0.0, 0.05);\n\n            // Starfield (Density reduced for mobile)\n            vec2 star_st = st * 60.0;\n            vec3 star_color = vec3(star(star_st, 0.1, 0.2));\n            star_color += vec3(star(star_st * 0.5, 0.15, 0.1));\n            color += star_color;\n\n            // Aurora Borealis\n            vec2 aurora_st = vUv;\n            aurora_st += u_rand_offset; // NEW: Apply the random offset\n            aurora_st.x *= 2.0;\n            aurora_st.y -= u_time * 0.03;\n            float n = fbm(aurora_st * 1.5);\n            float n2 = fbm(aurora_st * 2.5 + 10.0);\n            float aurora = smoothstep(0.4, 0.6, n) * (1.0 - smoothstep(0.5, 0.7, n));\n            float aurora2 = smoothstep(0.3, 0.8, n2) * (1.0 - smoothstep(0.6, 0.7, n2));\n            vec3 aurora_color = vec3(0.1, 0.9, 0.5);\n            vec3 aurora_color2 = vec3(0.2, 0.5, 0.9);\n            color += aurora * aurora_color * (1.0 - vUv.y);\n            color += aurora2 * aurora_color2 * (1.0 - vUv.y) * 0.5;\n\n            // Shooting Star\n            color += shooting_star(st, u_time);\n            \n            // Mountain Silhouette\n            vec2 mountain_st = vUv * vec2(1.5, 1.0);\n            float mountain_shape = mountain(mountain_st);\n            float mountain_mask = smoothstep(0.1, 0.15 + (vUv.x * (1.0-vUv.x) * 0.4) , vUv.y - mountain_shape * 0.4);\n            vec3 mountain_color = vec3(0.02, 0.03, 0.04);\n            color = mix(mountain_color, color, mountain_mask);\n\n            gl_FragColor = vec4(color, 1.0);\n        }\n    ",uniforms:r}),l=new a.bdM(2,2),c=new a.eaF(l,s);t.add(c);let u=()=>{let n=window.innerWidth,t=window.innerHeight;o.setSize(n,t),e.aspect=n/t,e.updateProjectionMatrix(),r.u_resolution.value.set(n,t)};window.addEventListener("resize",u);let f=new a.zD7,v=()=>{let n=f.getElapsedTime();r.u_time.value=n,o.render(t,e),window.requestAnimationFrame(v)};return v(),()=>{window.removeEventListener("resize",u),o.dispose(),l.dispose(),s.dispose()}},[]),(0,o.jsx)("canvas",{ref:n,className:"webgl"})}}}]);