"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[408],{6408:(e,n,t)=>{t.r(n),t.d(n,{default:()=>s});var o=t(5155),i=t(2115),r=t(3264),a=t(7431);let s=()=>{let e=(0,i.useRef)(null);return(0,i.useEffect)(()=>{if(!e.current)return;let n=new r.Z58,t=new r.ubm(75,window.innerWidth/window.innerHeight,.1,1e3);t.position.z=1;let o=new a.JeP({canvas:e.current,antialias:!0});o.setSize(window.innerWidth,window.innerHeight),o.setPixelRatio(window.devicePixelRatio);let i={u_time:{value:0},u_mouse:{value:new r.I9Y(0,0)},u_resolution:{value:new r.I9Y(window.innerWidth,window.innerHeight)}},s=new r.BKk({vertexShader:"\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            // Use this simple setup for a full-screen shader\n            gl_Position = vec4(position, 1.0);\n        }\n    ",fragmentShader:"\n        varying vec2 vUv;\n        uniform float u_time;\n        uniform vec2 u_mouse;\n        uniform vec2 u_resolution;\n\n        // 2D Random function\n        float random (vec2 st) {\n            return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n        }\n\n        // 2D Noise function\n        float noise (vec2 st) {\n            vec2 i = floor(st);\n            vec2 f = fract(st);\n\n            float a = random(i);\n            float b = random(i + vec2(1.0, 0.0));\n            float c = random(i + vec2(0.0, 1.0));\n            float d = random(i + vec2(1.0, 1.0));\n\n            vec2 u = f*f*(3.0-2.0*f);\n            return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n        }\n\n        // Fractional Brownian Motion for turbulence\n        float fbm(vec2 st) {\n            float value = 0.0;\n            float amplitude = 0.5;\n            for (int i = 0; i < 5; i++) {\n                value += amplitude * noise(st);\n                st *= 2.0;\n                amplitude *= 0.5;\n            }\n            return value;\n        }\n        \n        // Star generation\n        float star(vec2 st, float size, float twinkle_speed) {\n            vec2 grid = floor(st);\n            vec2 f = fract(st);\n            float star_val = random(grid);\n            \n            float t = u_time * twinkle_speed + star_val * 20.0;\n            float twinkle = sin(t) * 0.5 + 0.5;\n\n            if (star_val > 0.99) {\n                float m = 1.0 - smoothstep(0.0, size, length(f - 0.5));\n                return m * twinkle;\n            }\n            return 0.0;\n        }\n\n        void main() {\n            vec2 st = (gl_FragCoord.xy * 2.0 - u_resolution.xy) / u_resolution.y;\n            vec2 mouse = (u_mouse * 2.0 - u_resolution.xy) / u_resolution.y;\n            \n            // --- Background Nebula/Vortex Effect ---\n            vec2 q = vec2(0.0);\n            q.x = fbm(st + 0.00 * u_time);\n            q.y = fbm(st + vec2(1.0));\n\n            vec2 r = vec2(0.0);\n            r.x = fbm(st + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time);\n            r.y = fbm(st + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n            float f = fbm(st+r);\n\n            vec3 color = mix(vec3(0.1, 0.0, 0.4), // Deep blue/purple\n                             vec3(0.9, 0.2, 0.5), // Magenta/pink\n                             clamp((f*f)*3.0,0.0,1.0));\n\n            color = mix(color,\n                        vec3(0.0, 0.0, 0.0), // Black\n                        clamp(length(q),0.0,1.0));\n\n            color = mix(color,\n                        vec3(0.9, 1.0, 1.0), // White highlights\n                        clamp(length(r.x),0.0,1.0));\n            \n            color = (f*f*f+.6*f*f+.5*f)*color;\n\n            // --- Starfield ---\n            vec2 star_st = st * 30.0 + r * 2.0; \n            vec3 star_color = vec3(star(star_st, 0.15, 0.5));\n            color += star_color;\n\n            // --- Mouse Light ---\n            float mouse_dist = distance(st, mouse);\n            float mouse_glow = 1.0 - smoothstep(0.0, 0.15, mouse_dist);\n            color += mouse_glow * 0.5;\n\n            gl_FragColor = vec4(color, 1.0);\n        }\n    ",uniforms:i}),l=new r.bdM(2,2),u=new r.eaF(l,s);n.add(u);let c=e=>{i.u_mouse.value.x=e.clientX,i.u_mouse.value.y=window.innerHeight-e.clientY};window.addEventListener("mousemove",c);let v=()=>{let e=window.innerWidth,n=window.innerHeight;o.setSize(e,n),t.aspect=e/n,t.updateProjectionMatrix(),i.u_resolution.value.set(e,n)};window.addEventListener("resize",v);let f=new r.zD7,d=()=>{let e=f.getElapsedTime();i.u_time.value=e,o.render(n,t),window.requestAnimationFrame(d)};return d(),()=>{window.removeEventListener("mousemove",c),window.removeEventListener("resize",v),o.dispose(),l.dispose(),s.dispose()}},[]),(0,o.jsx)("canvas",{ref:e,className:"webgl"})}}}]);